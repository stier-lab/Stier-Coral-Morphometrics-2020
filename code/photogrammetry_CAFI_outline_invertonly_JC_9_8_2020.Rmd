---
output:
  html_document: default
  pdf_document: default
---
## Title: "Outline for Photogrammetry-CAFI manuscript"
author: "Joseph Curtis (modifying code by Journ Galvan)"
date: "9/8/2020"
output: html_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, include=FALSE}

rm(list=ls())

# Load libraries
library(here)
library(dplyr)
library(tidyverse)
library(vegan)
library(reshape)
library(ggplot2)
library(ggpubr)
library(zoo)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(psych)
library(knitr)
library(faraway)
library(car)
library(MASS)
library(gridExtra)
library(grid)
library(AER)
```

```{r, include=FALSE}
# Load data 
branch_width <- read.csv(here("photogrammetry_data","branchwidth_data.csv")) 
coral_pg <- read.csv(here("photogrammetry_data","galvan_journ_datasheet_v3.csv")) 
coral_field <- read.csv(here("photogrammetry_data","field_experiment_colony_measurements_moorea_summer2019.csv"))
updated_cafi <- read.csv(here("cafi_data","cafi_data_w_taxonomy_summer2019_2020_5_21.csv"))
```

```{r, include=FALSE}

# Data Preparation and Cleaning

# CAFI data - Inverts only
updated_cafi2 <- updated_cafi %>% filter(str_detect(coral_id, "^FE")) %>%
  dplyr::select(master_sort, coral_id, code, type, search_term, lowest_level, phylum, genus, species, general_notes) %>%
  subset(phylum!="Chordata") #filter out vertebrates

# Calculate CAFI richness, abundance, and diversity (shannon weiner) for each coral (inverts)

cafi_summarized2 <- group_by(updated_cafi2, coral_id) %>%
  summarise(num_cafi = n(), cafi_richness = length(unique(code)), cafi_present = paste(sort(unique(code)), collapse = ";"))
cafi_summarized2$sw <- updated_cafi2 %>% 
  count(code, coral_id = coral_id) %>% 
  spread(code,n) %>% 
  mutate_all(list(~tidyr::replace_na(.,0))) %>% 
  dplyr::select(-coral_id) %>% 
  diversity(index = "shannon")

# Clean field data
coral_field2 <- coral_field %>%
  dplyr::rename(branch = branch_width) 
  

# Clean photogrammetry morphometric data
coral_pg$volume_pg <- as.numeric(as.character(coral_pg$volume_pg)) # Convert factor to numeric
coral_pg <- coral_pg %>% filter(use == "y") %>%   mutate(volume_pg=volume_pg*10^6, #convert m^3 to cm^3
         max_hull_volume=max_hull_volume*10^6, #convert m^3 to cm^3
         max_hull_surface_area=max_hull_surface_area*10^4,#convert m^2 to cm^2
         surface_area=surface_area*10^4, #convert m^2 to cm^2
         height_pg=height_pg*100, #convert m to cm
         length_pg=length_pg*100, #convert m to cm
         width_pg=width_pg*100) #convert m to cm

# Clean photogrammetry branch width data and take averages of branch distance for each coral
branch_width$branch_distance_mm <- as.numeric(as.character(branch_width$branch_distance_mm)) # Convert factor to numeric
branch_w_summarized <- group_by(branch_width, coral_id) %>%
  summarise(avg_w_cm = mean(branch_distance_mm)/10, #take average branch distance and convert mm to cm
            measurements = n(), 
            locations = paste(sort(unique(location)), collapse = ";"))

#Create primary data frame for analysis

coral_dim <- merge(coral_pg, branch_w_summarized, by = "coral_id") %>%
 merge(coral_field2, by = "coral_id") %>%
  dplyr::rename(max_hull_SA = max_hull_surface_area,
                SA = surface_area)

# Swap width to be the bigger linear dimension, length to be the smaller one

coral_dim <- coral_dim %>% mutate(length_pg_temp = if_else(length_pg > width_pg, length_pg, width_pg),
                                  width_pg_temp = if_else(length_pg < width_pg, length_pg, width_pg),
                                  length_field_temp = if_else(length_field > width_field, length_field, width_field),
                                  width_field_temp = if_else(length_field < width_field, length_field, width_field)) %>% 
                            select(-length_pg, -width_pg, -length_field, -width_field) %>%
                            rename(length_pg = length_pg_temp, width_pg = width_pg_temp,
                                   length_field = length_field_temp, width_field = width_field_temp)
          


coral_dim$interstitial_space <- coral_dim$max_hull_volume - coral_dim$volume_pg #calculate available space by subtracting software estimated volume from convex hull volume

coral_dim$SAV <- coral_dim$SA / coral_dim$volume_pg #calculate surface area to volume relationship

coral_dim$convexity <- coral_dim$volume_pg / coral_dim$max_hull_volume #calculate proportion occupied, high ratios indicate less free space between branches

coral_dim$packing <- coral_dim$SA / coral_dim$max_hull_SA #how much of an objects surface area is situated internally

coral_dim$sphericity <- ((pi^(1/3))*((6*coral_dim$volume_pg)^(2/3)))/coral_dim$SA #calculate sphericity or how close the object is to a sphere

coral_dim$diff_est <- coral_dim$volume_field-coral_dim$volume_pg #actual overestimation

coral_dim$prop_est <- (coral_dim$volume_field - coral_dim$volume_pg)/coral_dim$volume_pg #proportion overestimated 

coral_dim <- coral_dim %>% dplyr::select(-"use", -position, -total_photos, -photos_not_aligned, -measurements, -locations) %>% 
  dplyr::rename(notes_pg = notes.x, notes_field = notes.y)

# Undid filtering of removal corals only.. may need to reintroduce step at some later point
  
# Merge coral and CAFI data
cafi_coral <- left_join(coral_dim, cafi_summarized2, by ="coral_id") %>% filter(cafi == "empty")

cafi_coral$branch_conv <- ifelse(cafi_coral$convexity>=0.5, "tight","wide") #classifies wide and tight branching coral based on convexity measurement (4 of 26 changed)

coral_dim$branch_conv <- ifelse(coral_dim$convexity>=0.5, "tight","wide") #classifies wide and tight branching coral based on convexity

#Create trimmed dataset (not sure why this df is necessary.. maybe clear later on?)
dim_bind <- coral_dim %>% select(coral_id, ends_with("pg"), ends_with("field")) %>% 
            mutate(prop_est=(volume_field-volume_pg)/volume_pg, #proportion overestimation of elipsoid compared to software volume
            diff_est=volume_field-volume_pg) #actual overestimation difference 
```

# Glossary/formulas

$Volume_{photo}$: Volume calculated through photogrammetry of live coral surface (base, epoxy, and background cropped) $(cm^3)$

$Volume_{hull}$: Volume of convex hull, or the greatest possible volume of coral object $(cm^3)$

$SA_{photo}$: Surface Area from photogrammetry models, only includes live coral surface, not underside of base $(cm^2)$

$SA_{hull}$: Surface Area from convex hull, lowest possible surface area of coral $(cm^2)$

Interstitial space: $Volume_{hull}$  - $Volume_{photo}$; higher value means more empty space in convex hull volume $(cm^3)$

SA/V: $SA_{photo}$/$Volume_{photo}$ (both from photogrammetry); proxy for rugosity, higher values mean more complex coral structure

Convexity: $Volume_{photo}$ / $Volume_{hull}$; proportion of convex hull occupied by object, lower values indicate more empty space inside convex hull. In a coral, this could be due to wide branch distance or higher complexity structure (convoluted, deep interstitial spaces) *note: We should discuss whether convexity is really the best measurement to try and divide "wide" and "tight" colonies. For instance, a colony with long, skinny branches and deep interstitial spaces could hypothetically have the same convexity as one with fatter, shorter branches with more space inbetween. I think convexity will catch the extreme cases (lowest values for very widely branched colonies, highest values for very tightly branched colonies), but I think the middle values could be tricky, and show "intermediate" tightness for different reasons*

Packing: $SA_{photo}$ / $SA_{hull}$; another measurement of rugosity and complexity, higher values suggest more structural complexity

Sphericity: ${\pi^{1/3}}*(6*Volume_{photo}^{2/3})/(SA_{photo})$; the degree to which the shape of a coral resembles a sphere - higher value means more spherical. *note: A coral could vary on a lot of different axes that decrease sphericity. A more complex, taller, or wider coral could all have similar sphericity values but for completely different reasons. I propose using convex hull measurements instead, which are better representations of actual coral shape.. but only if we think that'd be ecologically meaningful*


```{r, include=FALSE}

# Paired t-test for linear measurements and volume
par(mfrow=c(3,3))
qqPlot(dim_bind$height_pg, dist="norm")
qqPlot(dim_bind$height_field, dist="norm")
qqPlot(dim_bind$length_pg, dist="norm")
qqPlot(dim_bind$length_field, dist="norm")
qqPlot(dim_bind$width_pg, dist="norm")
qqPlot(dim_bind$width_field, dist="norm")
par(mfrow=c(2,2))

par(mfrow=c(2,2))
qqPlot(dim_bind$volume_pg, dist="norm")
qqPlot(dim_bind$volume_field, dist="norm")
par(mfrow=c(1,1))

#Volume data is not normal, try sqrt transformation
dim_bind$sqrt_volume_pg <- sqrt(dim_bind$volume_pg)
dim_bind$sqrt_volume_field <- sqrt(dim_bind$volume_field)

par(mfrow=c(2,2))
qqPlot(dim_bind$sqrt_volume_pg, dist="norm")
qqPlot(dim_bind$sqrt_volume_field, dist="norm")
par(mfrow=c(1,1))
#sqrt transformed volume for both measurements is normal, move to paired t-test
```

```{r, message=FALSE, include=TRUE}

#Perform paired t-tests

t_vol <- t.test(dim_bind$sqrt_volume_pg,dim_bind$sqrt_volume_field, paired=TRUE)
t_height <- t.test(dim_bind$height_pg,dim_bind$height_field, paired=TRUE)
t_length <- t.test(dim_bind$length_pg,dim_bind$length_field, paired=TRUE)
t_width <- t.test(dim_bind$width_pg,dim_bind$width_field, paired=TRUE)
```
